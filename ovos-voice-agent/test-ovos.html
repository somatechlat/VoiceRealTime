<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OVOS Voice Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 32px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 16px;
        }
        
        .status {
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }
        
        .status.disconnected {
            background: #fee;
            color: #c33;
            border: 2px solid #f66;
        }
        
        .status.connecting {
            background: #ffc;
            color: #960;
            border: 2px solid #fc0;
        }
        
        .status.connected {
            background: #efe;
            color: #3a3;
            border: 2px solid #6c6;
        }
        
        .buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        button {
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-connect {
            background: #667eea;
            color: white;
        }
        
        .btn-disconnect {
            background: #f66;
            color: white;
        }
        
        .btn-test {
            background: #6c6;
            color: white;
        }
        
        .mic-button {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 60px;
            border: none;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }
        
        .mic-button:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 12px 32px rgba(0,0,0,0.4);
        }
        
        .mic-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .mic-button.recording {
            background: linear-gradient(135deg, #f66, #c33);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .log {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            border-left: 3px solid #667eea;
            padding-left: 10px;
        }
        
        .log-entry.error {
            border-left-color: #f66;
            background: #fee;
        }
        
        .log-entry.success {
            border-left-color: #6c6;
            background: #efe;
        }
        
        .log-entry.info {
            border-left-color: #36c;
            background: #eef;
        }
        
        .clear-log {
            background: #999;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
            margin-top: 10px;
            min-width: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ OVOS Voice Test</h1>
        <p class="subtitle">Simple test interface for OVOS API</p>
        
        <div id="status" class="status disconnected">
            ‚ùå Not Connected
        </div>
        
        <div class="buttons">
            <button class="btn-connect" onclick="connectToOVOS()" id="connectBtn">
                Connect
            </button>
            <button class="btn-disconnect" onclick="disconnect()" id="disconnectBtn" disabled>
                Disconnect
            </button>
            <button class="btn-test" onclick="testAPI()">
                Test API
            </button>
            <button class="btn-test" onclick="sendText()" id="sendTextBtn" disabled>
                Send Text
            </button>
        </div>
        
        <button class="mic-button" id="micBtn" onclick="toggleRecording()" disabled>
            üé§
        </button>
        
        <div class="log" id="log">
            <div class="log-entry info">Ready to test. Click "Test API" first, then "Connect".</div>
        </div>
        
        <button class="clear-log" onclick="clearLog()">Clear Log</button>
    </div>

    <script>
        let ws = null;
        let mediaRecorder = null;
        let audioStream = null;
        let isRecording = false;
        
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const micBtn = document.getElementById('micBtn');
        
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function setStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        function clearLog() {
            logEl.innerHTML = '<div class="log-entry info">Log cleared.</div>';
        }
        
        async function testAPI() {
            log('Testing API connection...', 'info');
            
            try {
                // Test health endpoint
                const OVOS_CFG = window.OVOS_CONFIG || { VOICE_AGENT_BASE: 'http://localhost:60200', VOICE_AGENT_WS_BASE: 'ws://localhost:60200' };
                const healthResp = await fetch(`${OVOS_CFG.VOICE_AGENT_BASE}/health`);
                if (!healthResp.ok) throw new Error('Health check failed');
                const health = await healthResp.json();
                log(`‚úÖ Health: ${health.status}`, 'success');
                
                // Test client secret endpoint
                const secretResp = await fetch(`${OVOS_CFG.VOICE_AGENT_BASE}/v1/realtime/client_secrets`, {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer sk-local-token',
                        'Content-Type': 'application/json'
                    },
                    body: '{}'
                });
                
                if (!secretResp.ok) {
                    const text = await secretResp.text();
                    throw new Error(`Client secret failed: ${secretResp.status} - ${text}`);
                }
                
                const secretData = await secretResp.json();
                log(`‚úÖ Got client secret: ${secretData.value.substring(0, 20)}...`, 'success');
                log('‚úÖ API is working! You can now connect.', 'success');
                
            } catch (error) {
                log(`‚ùå API Test Failed: ${error.message}`, 'error');
                console.error('API test error:', error);
            }
        }
        
        async function connectToOVOS() {
            try {
                setStatus('‚è≥ Connecting...', 'connecting');
                log('Getting client secret...', 'info');
                
                // Get client secret
                const secretResp = await fetch(`${OVOS_CFG.VOICE_AGENT_BASE}/v1/realtime/client_secrets`, {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer sk-local-token',
                        'Content-Type': 'application/json'
                    },
                    body: '{}'
                });
                
                if (!secretResp.ok) {
                    throw new Error(`Failed to get secret: ${secretResp.status}`);
                }
                
                const secretData = await secretResp.json();
                const clientSecret = secretData.value;
                log(`Got secret: ${clientSecret.substring(0, 20)}...`, 'success');
                
                // Create session
                log('Creating session...', 'info');
                const sessionResp = await fetch(`${OVOS_CFG.VOICE_AGENT_BASE}/v1/realtime/sessions`, {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer sk-local-token',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ client_secret: clientSecret })
                });
                
                if (!sessionResp.ok) {
                    throw new Error(`Failed to create session: ${sessionResp.status}`);
                }
                
                const sessionData = await sessionResp.json();
                log(`Session created: ${sessionData.session.id}`, 'success');
                
                // Connect WebSocket
                log('Opening WebSocket...', 'info');
                const wsUrl = `${OVOS_CFG.VOICE_AGENT_WS_BASE}/v1/realtime?access_token=${encodeURIComponent(clientSecret)}`;
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    log('‚úÖ WebSocket connected!', 'success');
                    setStatus('‚úÖ Connected to OVOS', 'connected');
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    micBtn.disabled = false;
                    document.getElementById('sendTextBtn').disabled = false;
                };
                
                ws.onmessage = (event) => {
                    let data;
                    try {
                        data = JSON.parse(event.data);
                    } catch (e) {
                        log('‚ùå Invalid WS JSON', 'error');
                        return;
                    }
                    const t = data.type;
                    if (!t) {
                        log('üì® Received unknown event', 'info');
                        return;
                    }
                    // Always log event type for traceability
                    log(`üì® ${t}`, 'info');
                    // Show errors prominently
                    if (t === 'error' && data.error) {
                        log(`‚ùå ${data.error.code || 'error'}: ${data.error.message}`, 'error');
                        return;
                    }
                    // Display assistant text as it streams
                    if (t === 'response.audio_transcript.delta' && data.delta) {
                        log(`ü§ñ ${data.delta}`, 'success');
                        return;
                    }
                    // Some implementations may send output_text delta events
                    if (t === 'response.output_text.delta' && data.delta) {
                        log(`ü§ñ ${data.delta}`, 'success');
                        return;
                    }
                    // When a full assistant item is added, extract its text
                    if (t === 'response.output_item.added' && data.item && Array.isArray(data.item.content)) {
                        const part = data.item.content.find(p => p.type === 'output_text' && p.text);
                        if (part && part.text) {
                            log(`ü§ñ ${part.text}`, 'success');
                        }
                        return;
                    }
                    // Play audio when provided as a single delta containing a WAV payload
                    if (t === 'response.audio.delta' && data.delta) {
                        try {
                            const base64 = data.delta;
                            const bin = atob(base64);
                            const bytes = new Uint8Array(bin.length);
                            for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
                            const blob = new Blob([bytes], { type: 'audio/wav' });
                            const url = URL.createObjectURL(blob);
                            const audio = new Audio(url);
                            audio.play().catch(() => {/* ignore auto-play block */});
                            log('üîä Playing assistant audio', 'success');
                        } catch (e) {
                            log('‚ùå Failed to play audio', 'error');
                        }
                        return;
                    }
                    console.log('WS message:', data);
                };
                
                ws.onerror = (error) => {
                    log('‚ùå WebSocket error', 'error');
                    console.error('WS error:', error);
                };
                
                ws.onclose = () => {
                    log('WebSocket closed', 'info');
                    setStatus('‚ùå Disconnected', 'disconnected');
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    micBtn.disabled = true;
                    document.getElementById('sendTextBtn').disabled = true;
                    ws = null;
                };
                
            } catch (error) {
                log(`‚ùå Connection failed: ${error.message}`, 'error');
                setStatus('‚ùå Connection Failed', 'disconnected');
                console.error('Connect error:', error);
            }
        }
        
        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
            log('Disconnected', 'info');
        }

        function sendText() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('WS not connected', 'error');
                return;
            }
            const text = prompt('Say something to the assistant:', 'Hello there');
            if (!text) return;
            ws.send(JSON.stringify({
                type: 'conversation.item.create',
                item: { role: 'user', content: [{ type: 'input_text', text }] }
            }));
            setTimeout(() => ws.send(JSON.stringify({ type: 'response.create' })), 200);
            log('Sent input_text and requested response', 'info');
        }
        
        async function toggleRecording() {
            if (!isRecording) {
                await startRecording();
            } else {
                await stopRecording();
            }
        }
        
        async function startRecording() {
            try {
                log('üé§ Starting recording...', 'info');
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(audioStream);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0 && ws && ws.readyState === WebSocket.OPEN) {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const arrayBuffer = reader.result;
                            const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                            ws.send(JSON.stringify({
                                type: 'input_audio_buffer.append',
                                audio: base64
                            }));
                        };
                        reader.readAsArrayBuffer(event.data);
                    }
                };
                
                mediaRecorder.start(100);
                isRecording = true;
                micBtn.classList.add('recording');
                micBtn.textContent = '‚èπÔ∏è';
                log('üé§ Recording... Click to stop', 'success');
                
            } catch (error) {
                log(`‚ùå Recording failed: ${error.message}`, 'error');
                console.error('Recording error:', error);
            }
        }
        
        async function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            isRecording = false;
            micBtn.classList.remove('recording');
            micBtn.textContent = 'üé§';
            log('‚èπÔ∏è Recording stopped', 'info');
            
            // Send commit and request response
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'input_audio_buffer.commit' }));
                setTimeout(() => {
                    ws.send(JSON.stringify({ type: 'response.create' }));
                }, 500);
            }
        }
        
        // Auto-test on load
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('Page loaded. Click "Test API" to verify connection.', 'info');
            }, 500);
        });
    </script>
</body>
</html>
